# -*- coding: utf-8 -*-

# Dirichlet Mixing Module v1.2
# Implemented by Simon Matthews, based on original MatLab code by John Rudge.
# Mathematics described in Rudge et al.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Mean composition of melts from all lithologies
def mean_comp_total(f,w,c):
    return np.sum(f*c*w)

# Import a Melts output file
def Import_Melts_output(filename,dX=0.0001,RudgeMethod=False):
    """Import a Melts csv file and recasts the melting column in terms of equal
    dX increments. Converts pressure from bars to GPa.

    Returns a pandas dataframe.

    Parameters
    ----------

    filename: string
        Name of the file (and path relative to script) to import

    dX: float
        Discretization interval. Default 0.01%.

    RudgeMethod: bool
        Use the Rudge method for calculating melt fraction from the MELTS input.
        I think this method is erroneous, but have kept it so his results may be
        reproduced.

    """
    meltsFile = pd.read_csv(filename,skiprows=1)
    if RudgeMethod == True:
        # Calculate Melt Fraction
        meltsFile['F'] = (100-meltsFile.Mass)/100
        # Calculate residual porosity
        ResidualPorosity = meltsFile.F.iloc[0]
        X = (meltsFile.F - ResidualPorosity)/(1-ResidualPorosity)
    else:
        X = (meltsFile.Mass[0]-meltsFile.Mass)/meltsFile.Mass[0]

    # Find last X=0 term during upwelling (and first DeltaX>0 term)
    # Find last melting step
    MeltingBounds = [0,0]
    MeltingBounds[0] = np.argmin(X[X>0]) - 1
    MeltingBounds[1] = np.argmax(X)

    # Make list of columns for new array
    columns = ['X','P','T']
    columns = columns + (meltsFile.columns[3:].tolist())

    # Set up list of X values to map all other variables to
    X_to_map = np.arange(X[MeltingBounds[0]],X[MeltingBounds[1]],dX)

    # Create an array of zeroes with the length of the number of rows needed in the dataframe
    EmptyColumns = np.array([np.zeros(np.shape(X_to_map))]*np.shape(columns)[0]).T

    # Create Empty Dataframe
    d = pd.DataFrame(EmptyColumns, columns=columns)

    # Start filling Dataframe
    d.X = X_to_map
    d['T'] = np.interp(d.X,X,meltsFile.Temperature)
    d['P'] = np.interp(d.X,X,meltsFile.Pressure)/1e4

    # Map all the chemistry to the new X variable
    for col in columns[3:]:
        d[col] = np.interp(d.X,X,meltsFile[col])

    return d

# Import a Melts output file
def Import_Katz_output(filename,dX=0.0001,MajorElements=pd.Series([7.48,8.51],index=['MgO','FeO']),WalterComps=False,file=True):
    """Import a numpy file generated by the single melting region function of
    the DualLithologyMelting script and recasts the melting column in terms of equal
    dX increments.

    Returns a pandas dataframe.

    Parameters
    ----------

    filename: string
        Name of the file (and path relative to script) to import

    dX: float
        Discretization interval. Default 0.01%.

    MajorElements: series
        Major Element concentrations to add to each fractional melt. Same composition
        will apply to all melts. MgO and FeO must always be set, otherwise some
        functionality of the dirichlet module won't work (but can be ignored).

    WalterComps: bool
        If true the major element composition of the melts will be calculated using
        the parameterisation of the Walter KR4003 melting experiments by Duncan et al.
        (2017).
    file: bool
        If true filename is interpreted as a file name, if false, filename is interpreted
        as the array object itself.

    """
    if file == True:
        mr_raw = np.load(filename)
    else:
        mr_raw = filename
    mr = np.zeros([3,np.shape(mr_raw)[1]])
    mr[0] = mr_raw[0]
    mr[1] = mr_raw[1]
    mr[2] = mr_raw[3]
    mr = pd.DataFrame(mr.T,columns=['P','T','X'])

    # Find last X=0 term during upwelling (and first DeltaX>0 term)
    # Find last melting step
    MeltingBounds = [0,0]
    MeltingBounds[0] = np.argmin(mr.X[mr.X>0]) - 1
    MeltingBounds[1] = np.argmax(mr.X)


    # Make list of columns for new array
    columns = ['X','P','T']
    if WalterComps == False:
        columns = columns + MajorElements.index.tolist()

    # Set up list of X values to map all other variables to
    X_to_map = np.arange(mr.X[MeltingBounds[0]],mr.X[MeltingBounds[1]],dX)

    # Create an array of zeroes with the length of the number of rows needed in the dataframe
    EmptyColumns = np.array([np.zeros(np.shape(X_to_map))]*np.shape(columns)[0]).T

    # Create Empty Dataframe
    d = pd.DataFrame(EmptyColumns, columns=columns)

    # Start filling Dataframe
    d.X = X_to_map
    d['T'] = np.interp(d.X,mr.X,mr['T'])
    d['P'] = np.interp(d.X,mr.X,mr.P)
    if WalterComps == False:
        for el in MajorElements.index:
            d[el] = MajorElements[el]

    if WalterComps == True:
        MajorElements = WalterComposition(np.array(d.X),np.array(d.P))[0]
        d = pd.merge(d,MajorElements,on=['X','P'])

    return d

# Import a MultiLith output file
def Import_MultiLith_output(mr_raw,dX=0.0001,MajorElements=pd.Series([7.48,8.51],index=['MgO','FeO']),WalterComps=False):
    """Import a 1D melting region object generated by the MultiLith code. Must have been
    integrated already.

    Returns a pandas dataframe.

    Parameters
    ----------

    filename: string
        Name of the file (and path relative to script) to import

    dX: float
        Discretization interval. Default 0.01%.

    MajorElements: series
        Major Element concentrations to add to each fractional melt. Same composition
        will apply to all melts. MgO and FeO must always be set, otherwise some
        functionality of the dirichlet module won't work (but can be ignored).

    WalterComps: bool
        If true the major element composition of the melts will be calculated using
        the parameterisation of the Walter KR4003 melting experiments by Duncan et al.
        (2017).

    """

    steps_under_crust = np.shape(mr_raw.P[mr_raw.P>mr_raw.P_base_of_crust])[0]

    lithologies = len(mr_raw.mantle.names)

    mcols = list()
    for lith in mr_raw.mantle.names:
        mr = np.zeros([3,steps_under_crust])
        mr[0] = mr_raw.P[:steps_under_crust]
        mr[1] = mr_raw.Temperature[:steps_under_crust]
        mr[2] = mr_raw.F[lith][:steps_under_crust]
        mr = pd.DataFrame(mr.T,columns=['P','T','X'])

        # Find last X=0 term during upwelling (and first DeltaX>0 term)
        # Find last melting step
        if np.shape(mr.X[mr.X>0])[0] != 0:
            MeltingBounds = [0,0]
            MeltingBounds[0] = mr.X[mr.X>0].idxmin() - 1
            MeltingBounds[1] = mr.X[mr.X>0].idxmax()


            # Make list of columns for new array
            columns = ['X','P','T']
            if WalterComps == False:
                columns = columns + MajorElements.index.tolist()

            # Set up list of X values to map all other variables to
            X_to_map = np.arange(mr.X[MeltingBounds[0]],mr.X[MeltingBounds[1]],dX)

            # Create an array of zeroes with the length of the number of rows needed in the dataframe
            EmptyColumns = np.array([np.zeros(np.shape(X_to_map))]*np.shape(columns)[0]).T

            # Create Empty Dataframe
            d = pd.DataFrame(EmptyColumns, columns=columns)

            # Start filling Dataframe
            d.X = X_to_map
            d['T'] = np.interp(d.X,mr.X,mr['T'])
            d['P'] = np.interp(d.X,mr.X,mr.P)
            if WalterComps == False:
                for el in MajorElements.index:
                    d[el] = MajorElements[el]

            if WalterComps == True:
                MajorElements = WalterComposition(np.array(d.X),np.array(d.P))[0]
                d = pd.merge(d,MajorElements,on=['X','P'])

            mcols.append(d)
    if lithologies == 1:
        return d
    else:
        return mcols

class MeltingColumn:
    """The meltingColumn class is for single fractional melt columns, defined by dX.
    Pass a melting column of abitrary definition, with a dX and it will be remapped.
    The column should only be from the onset of melting to end of melting. Mixing weights,
    assuming a triangular melting region, will be generated.

    self.column is the melting column variables.
    self.lithology is the assigned lithology label

    Parameters
    ----------
    Input: dataframe
        Melting column input, recast into equal dX intervals. Most probably passing
        the output of the Import_Melts_ouput() function.

    dX: float
        The discretization interval used to generate the Input.

    lithology: string
        Label for the lithology melting in the column. Default is default.

    MeltingRegionShape: string
        Shape to use for weighting. Default is 'tri' for a triangular melting region.
        'toptri' will apply a zero weighting to all pressures > MeltingRegionParam,
        'bottri' will do the reverse.
    MeltingRegionParam: float
        If using a melting region shape which requires parameters to define, pass
        them here.

        """
    def __init__(self,Input,dX=0.0001,lithology='default',MeltingRegionShape='tri',MeltingRegionParam=0.0):
        self.column = Input
        self.lithology = lithology
        # Generate a weight function for triangular melting region, P is pressure, X is melt fraction
        if MeltingRegionShape == 'tri':
            self.column['w'] = np.linspace(1,0,np.shape(self.column.P)[0])
            self.column['w_normed'] = self.column['w']/np.sum(self.column['w'])
        elif MeltingRegionShape == 'toptri':
            _exc = self.column.P[self.column.P>MeltingRegionParam]
            _w = np.zeros(np.shape(self.column.P)[0])
            _w[np.shape(_exc)[0]:] = np.linspace(1,0,np.shape(self.column.P)[0]-np.shape(_exc)[0])
            self.column['w'] = _w
            self.column['w_normed'] = self.column['w']/np.sum(self.column['w'])
        elif MeltingRegionShape == 'bottri':
            _exc = self.column.P[self.column.P<MeltingRegionParam]
            _w = np.zeros(np.shape(self.column.P)[0])
            _w[:np.shape(self.column.P)[0]-np.shape(_exc)[0]] = np.linspace(1,0,np.shape(self.column.P)[0])[:np.shape(self.column.P)[0]-np.shape(_exc)[0]]
            self.column['w'] = _w
            self.column['w_normed'] = self.column['w']/np.sum(self.column['w'])

    def mean_comp(self):
        """Returns the mean composition of melts produced in the melting column,
        weighted by w contained in the MeltingColumn object. Returns a Pandas series."""
        _c = self.column.drop(['X','P','T','w','w_normed'],axis=1)
        _w = np.array([self.column.w_normed]*np.shape(_c)[1]).T
        return (_w*_c).sum()

    def add_isotope(self,El,isotopes,ratio):
        """Adds two isotopes of an element already existing in a melting column,
        in the proportions determined by the ratio. Adds two new columns with the
        isotope names.

        Parameters
        ----------
        El:     str
            Element name. Must match the name of an element already in the column

        isotopes:     list
            List of isotope mass numbers, length 2.

        ratio:     float
            Ratio of the two isotopes. The first in the list above should be the
            numerator, the second the denominator.
        """
        _newcols = list()
        for m in isotopes:
            _newcols.append(str(m)+El)
        self.column[_newcols[0]] = self.column[El]/(1/ratio+1)
        self.column[_newcols[1]] = self.column[El]/(ratio+1)

    def add_element(self,El,Cs,D,p=0):
        """Adds an element to the melting column, assuming fractional or continuous
        melting described by a fixed value of D and porosity.

        Parameters
        ----------
        El:     str
            Element Name. Must not match an element already in the column.
        Cs:     float
            Element concentration in the source. This will usually be ppm.
        D:      float
            Partition coefficient for the element.
        p:      float
            Porosity. Set to 0 for fractional melting."""

        # Adjust D parameter for continuous melting (White Geochemistry Eq 7.52)
        D = (1-p)*D + p

        self.column[El] = Cs*(1/D)*(1-self.column['X'])**(1/D-1)

    def duplicate_element(self,El,name,CsRatio):
        """
        Duplicates the melting behaviour of an existing element in the column, in
        order to imitate the behaviour of another element. The concentration can
        be fixed by providing the ratio of concentrations in the solid.

        Parameters
        ----------
        El:     str
            Existing element to duplicate.
        name:   str
            Name of the new element
        CsRatio:    float
            Ratios of the concentrations of the two elements in the solid. New/Old.
        """

        self.column[name] = CsRatio * self.column[El]

    def trace_to_oxide(self,trace,oxide,elMass=1.0,oxMass=1.0):
        """
        Converts elements calculated as ppm trace elements by MELTS into wt% oxides.

        Parameters
        ----------
        trace:  str
            Trace element name
        oxide:  str
            Name to call new oxide
        elMass: float
            Mass of element in oxide formula, i.e. K2O would have elMass = 2*K. Set
            automatically if Na or K (and oxide set to Na2O or K2O).
        oxideMass: float
            Mass per mole of oxide. Set
            automatically if Na2O or K2O (and trace set to Na or K).
        """

        if trace == 'K' and oxide == 'K2O':
            elMass = 39.098*2
            oxMass = 39.098*2 + 16
        if trace == 'Na' and oxide == 'Na2O':
            elMass = 22.99*2
            oxMass = 22.99*2 + 16

        self.column[oxide] = self.column[trace]/elMass*oxMass/1e4


class Melt:
    """This is currently a placeholder class for when models using individual melts
    are created, akin to Shorttle et al. (2016). This could maybe be absorbed into the
    MeltingColumn class."""
    def __init__(self,Input,name='default'):
        self.composition = Input
        self.name = name
        self.w = 1

class UnmixedMelts:
    """Class consisting of a dataframe (.melts) of all individual melts to be mixed, with
    their appropriate mixing parameters, w for melts within a single column (should
    be passed in the the list of MeltingColumn objects, melts variable) and p
    for lithology proportions (pass in proportions list).
    NOTE: melts must consist of MeltingColumn objects.

    Parameters
    ----------
    MeltingColumns:     list
        List of MeltingColumn objects

    propotions:     list
        List of the proportions of each melting column

    """
    def __init__(self,MeltingColumns,proportions):
        if np.shape(MeltingColumns) != np.shape(proportions):
            print('Lists passed must have the same length')
        else:
            # Create an empty list to store the dataframes
            _Cols = list()
            self.proportions = proportions
            # Create an empty list to store lithology names
            self.lithologies = list()

            # Calculate the denominator in the fraction for f weights
            _denom = 0
            for MeltingColumn, p in zip(MeltingColumns,proportions):
                _dX = MeltingColumn.column.X[1]-MeltingColumn.column.X[0]
                _denom = _denom + (MeltingColumn.column.w*_dX*p).sum()

            # For each column passed, calculate f and apply to each melt
            for MeltingColumn,p in zip(MeltingColumns,proportions):
                _dX = MeltingColumn.column.X[1]-MeltingColumn.column.X[0]
                _numer = (MeltingColumn.column.w*_dX*p).sum()
                MeltingColumn.column['f'] = [_numer/_denom]*np.shape(MeltingColumn.column)[0]
                # Add a 'fake element' with the name of the lithology, to calculate the contribution
                # of lithologies to the melt
                MeltingColumn.column[MeltingColumn.lithology] = [1]*np.shape(MeltingColumn.column)[0]
                # Create a list of dataframes so they can be concatenated
                _Cols.append(MeltingColumn.column)
                self.lithologies.append(MeltingColumn.lithology)
            self.melts = pd.concat(_Cols,ignore_index=True)
            self.melts = self.melts.fillna(0)

            todrop = self.melts.index[self.melts.w==0].tolist()
            self.melts = self.melts.drop(todrop)

    NonCompVars = ['w','w_normed','f','T','X','P']

    def gen_alpha(self,N):
        """Generate dirichlet parameters given the N passed to function, and the
        p and w weighting variables contained in UnmixedMelts object.

        Returns a pandas series

        Parameters
        ----------
        N: float or int
            Mixing parameter. Must be >1."""
        return (N-1)*self.melts.f*self.melts.w_normed

    def gen_mixing_weights(self,N):
        """Generate a random distribution of mixing weights, as defined by the
        dirichlet distribution with mixing parameter N and the p and w weightings
        of the UnmixedMelts object.

        Returns a pandas series

        Parameters
        ----------
        N: float or int
            Mixing parameter. Must be >1.
        """
        _alpha = self.gen_alpha(N)
        return np.random.dirichlet(_alpha)

    def gen_mixed_melts(self,N,n):
        """Generate n different mixed melts with mixing parameters randomly selected
        from the dirichlet distribution defined by the mixing parameter N and the
        w and p weightings of the UnmixedMelts object.

        Returns a pandas dataframe.

        Parameters
        ----------
        N: float or int
            Mixing parameter. Must be >=1.

        n: int
            Number of mixed melts to return."""
        _C = self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],axis=1)

        _mixed = pd.DataFrame(columns=_C.columns)

        if N == 1:
            _wts = self.melts.w_normed*self.melts.f
            for i in range(n):
                _randindex = np.random.choice(_C.index,1,list(_wts))[0]
                _mixed = _mixed.append(_C[_C.index == _randindex],ignore_index=True)

        else:
            for i in range(n):
                # Make an array of r values for each column:
                _r = np.array([self.gen_mixing_weights(N)]*np.shape(_C)[1]).T
                _mix = (_r*_C).sum()

                _mixed = _mixed.append(_mix,ignore_index=True)

        _Mg = _mixed.MgO/(24.3+16)
        _Fe = _mixed.FeO/(55.8+16)
        _mixed['Fo'] = 100/(_Fe*0.3/_Mg+1)

        return MixedMelts(_mixed,N)

    def gen_cmc_melts(self,n,Cmax,Nmin,Nmax,a):
        """
        Generate melts produced by concurrent mixing and crystallisation, using the
        model defined in Rudge et. al.

        Parameters
        ----------
        n: int
            Number of mixed melts to produce.

        Cmax: float
            Maximum fraction of crystallisation. Denoted by Chi in Rudge et. al.

        Nmin: float or int
            Minimum degree of melt mixing

        Nmax: float or int
            Maximum degree of melt mixing

        a: float or int
            Parameter controlling the decrease in Fo with increased crystallisation.
            Denoted by alpha in Rudge et. al.

        """
        _Comp = self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],axis=1)

        # Generate uniform random variable U:
        _U = np.random.uniform(0.0,1.0,n)

        _C = Cmax * _U**2
        _N = Nmin*(Nmax/Nmin)**_U

        _mixed = pd.DataFrame(columns=_Comp.columns+['Fo'])

        for i,Ni in zip(range(n),_N):
            if Ni == 1:
                _wts = self.melts.w_normed*self.melts.f
                _randindex = np.random.choice(_Comp.index,1,list(_wts))
                _mix = _Comp[_Comp.index==_randindex]
            else:
                _r = np.tile(np.array([self.gen_mixing_weights(Ni)]),(np.shape(_Comp)[1],1)).T
                _mix = (_r*_Comp).sum()
            _Mg = _mix['MgO']/(24.3+16)
            _Fe = _mix['FeO']/(55.8+16)
            _Fo = 100/(_Fe*0.3/_Mg+1) - a*_C[i]
            _mix = (_r*_Comp).sum()/(1-_C[i])
            _mix['Fo'] = _Fo
            _mixed = _mixed.append(_mix,ignore_index=True)

        return MixedMelts(_mixed,0)

    def mean_comp(self):
        """Generate the mean composition of all melts in the UnmixedMelts object,
        weighted by the w and p values of the object."""
        _C = self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],axis=1)
        _w = np.array([self.melts.w_normed]*np.shape(_C)[1]).T
        _f = np.array([self.melts.f]*np.shape(_C)[1]).T
        return (_f*_w*_C).sum()

    def homogenise(self,pressure,F=False):
        """Homogenise melts produced below a certain pressure or melt fraction,
        weighted by the w and p values of the object.

        Parameters
        ----------

        pressure: float
            Pressure at which to homogenise melts generated beneath. Set to False
            to use melt fraction instead.
        F:  float
            melt fraction to use in place of pressure."""
        _C = self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],axis=1)
        if pressure != False:
            _C = _C[self.melts.P > pressure]
            _wf = self.melts.w_normed[self.melts.P > pressure]*self.melts.f[self.melts.P > pressure]

        else:
            _C = _C[self.melts.X < F]
            _wf = self.melts.w_normed[self.melts.X < F]*self.melts.f[self.melts.X < F]
        _wf_normed = _wf/_wf.sum()
        _wf_normed = np.tile(np.array(_wf_normed),(np.shape(_C)[1],1)).T

        _homogenised = (_wf_normed*_C).sum()

        for index, row in self.melts.iterrows():
            if pressure != False:
                if row.P > pressure:
                    for col in _C.columns:
                        self.melts.loc[index,col] = _homogenised[col]
            else:
                if row.X < F:
                    for col in _C.columns:
                        self.melts.loc[index,col] = _homogenised[col]

    def variance(self,elements=None,M=1):
        """Calculate the variance for elements at a specified degree of mixing. Uses
        the equation given in the appendix of Rudge et al.

        Parameters
        ----------
        elements: list or string
            elements to calculate variance for. If set to none (default), a series
            with the variance of each element in the unmixed melts object will be
            returned.
        M:  float or int
            Mixing parameter.

        Returns
        -------
        variance: series
            Series with element names as index.
        """

        if elements is None:
            elements = list(self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],
                                                               axis=1).columns.values)
        if isinstance(elements,str):
            elements = [elements]

        meanComps = self.mean_comp()
        variances = list()
        for el in elements:
            variances.append(np.sum(self.melts.f*self.melts.w_normed*(self.melts[el]-meanComps[el])**2)/M)

        return pd.Series(variances,index=elements)

    def covariance(self,elements=None,elements2=None,M=1):
        """Calculate the covariance between each element given, for a given
        mixing parameter.

        Parameters
        ----------
        elements: list or string
            elements to calculate variance for. If set to none (default), a series
            with the variance of each element in the unmixed melts object will be
            returned.
        elements2: list or string
            if not set to none, it will compare this list of elements only with the
            list in the elements variable
        M:  float or int
            Mixing parameter.

        Returns
        -------
        covariance: nxn dataframe
            DataFrame containing the covariances with elements as the indexes
            and columns.
        """

        if elements is None:
            elements = list(self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],
                                                               axis=1).columns.values)
        if isinstance(elements,str):
            elements = [elements]

        if isinstance(elements2,str):
            elements2= [elements2]
        if elements2 is None:
            elements2 = elements

        meanComps = self.mean_comp()

        covs = np.zeros([np.shape(elements)[0],np.shape(elements2)[0]])

        for i,el1 in zip(range(np.shape(elements)[0]),elements):
            for j,el2 in zip(range(np.shape(elements2)[0]),elements2):
                covs[i,j] = (np.sum(self.melts.f*self.melts.w_normed*(self.melts[el1]-meanComps[el1])*
                                    (self.melts[el2]-meanComps[el2]))/M)

        return pd.DataFrame(covs,index=elements,columns=elements2)

    def correlation(self,elements,elements2):
        """
        Calculates the correlation coefficient between elements. This is independent
        of the mixing parameter.

        Parameters
        ----------
        elements: list or string
            elements to calculate variance for. If set to none (default), a series
            with the variance of each element in the unmixed melts object will be
            returned.
        elements2: list or string
            if not set to none, it will compare this list of elements only with the
            list in the elements variable

        Returns
        -------
        correlation: nxn dataframe
            DataFrame containing the correlations with elements as the indexes
            and columns.
        """

        if elements is None:
            elements = list(self.melts.drop(self.melts.columns[self.melts.columns.isin(UnmixedMelts.NonCompVars)],
                                                               axis=1).columns.values)

        if isinstance(elements,str):
            elements = [elements]

        if isinstance(elements2,str):
            elements2= [elements2]
        if elements2 is None:
            elements2 = elements

        cors = np.zeros([np.shape(elements)[0],np.shape(elements2)[0]])

        vars1 = self.variance(elements)
        vars2 = self.variance(elements2)
        covs = self.covariance(elements,elements2)

        for i,el1 in zip(range(np.shape(elements)[0]),elements):
            for j,el2 in zip(range(np.shape(elements2)[0]),elements):
                cors[i,j] = covs.iloc[i,j]/np.sqrt(vars1.iloc[i]*vars2.iloc[j])

        return pd.DataFrame(cors,index=elements,columns=elements2)


class MixedMelts:
    """Class containing a dataframe of mixed melts.

    Parameters
    ----------
    melts: dataframe
    Dataframe of mixed melts. Rows are individual melts. Columns are elements.

    N: float or int
    Mixing parameter used to generate the melts.

    """

    def __init__(self,melts,N):
        self.melts = melts
        self.N = N
#        self.gen_Fo(0.3)



#    def gen_Fo(self,kd):
#        """Calculate the Forsterite content of the olivine in equilibrium with
#        the mixed melts.
#        Parameters
#        ----------
#        kd: float
#        The kd for melt-liquid equilibrium."""
#
#        _Fe = self.melts.FeO/(55.8+16)
#        _Mg = self.melts.MgO/(24.3+16)
#
#        _MgFeOl = _Mg/_Fe/kd
#
#        self.melts['Fo'] = 100/(1/_MgFeOl+1)

def PlotVariableMixing(Mixed,M,xvar,yvar,filename=None,xden=1,yden=1,xlim=None,ylim=None):
    """Plots Rudge et al. style variable mixing plots.

    Parameters
    ----------

    MixedMelts: list of dataframes
    List containing 9 dataframes, corresponding to mixed melts.

    M: list
    List containing the 9 values of the mixing parameter, for inclusion as text

    xvar: str
    Element or isotope to plot on x axis. Numerator if ratio.

    yvar: str
    Element or isotope to plot on y axis. Numerator if ratio.

    filename: str
    Name of file when saving figure. 'default' will save it with element names.

    xden: str
    If plotting a ratio on x, provide denominator element or isotope.

    yden: str
    If plotting a ratio on y, provide denominator element or isotope.
    """

    if np.shape(Mixed)[0] != 9 or np.shape(M)[0] != 9:
        print('Error: Must provide 9 inputs')
    else:
        fig = plt.figure(figsize=(8,8))

        for p,m in zip(range(9),Mixed):
            ax = fig.add_subplot(3,3,(p+1))
            if isinstance(xden, str):
                xd = m.melts[xden]
                ax.set_xlabel(xvar+'/'+xden)
            else:
                xd=1
                ax.set_xlabel(xvar)
            if isinstance(yden, str):
                yd = m.melts[yden]
                ax.set_ylabel(yvar+'/'+yden)
            else:
                yd=1
                ax.set_ylabel(yvar)
            if xlim != None:
                ax.set_xlim(xlim)
            if ylim != None:
                ax.set_ylim(ylim)
            ax.scatter(m.melts[xvar]/xd,m.melts[yvar]/yd,c=m.melts.Px.convert_objects(convert_numeric=True),vmin=0,vmax=1,s=4,lw=0)
            ax.annotate('N='+str(M[p]),xy=(0.9,0.9),xycoords='axes fraction',fontsize=12,ha='right',va='top')
            fig.tight_layout()

        if filename == None:
            filename = xvar + '-' + str(xden) + '-' + yvar +'-' + str(yden) +'.png'
        plt.savefig(filename,dpi=200)
        plt.show()

def WalterComposition(F,P):
    """
    Calculates the melt composition generated as a function of F and P, using the
    parameterisation of Duncan et al. (2017).

    Parameters
    -----
    F: float
        Melt fraction
    P: float
        Pressure in GPa

    Returns
    -----
    MeltComposition: series
        Major elements in wt%
    T: float
        Temperatures associated with the melt in C
    """

    if isinstance(F,float):
        F = np.array([F])
        P = np.array([P])
    if isinstance(F,list):
        F = np.array(F)
        P = np.array(P)

    comp = pd.DataFrame(np.array([P,F]).T,columns=['P','X'])

    F = F*100

    if F[F.argmin()] == 0:
        F[F.argmin()] = F[F.argmin()+1]



    comp['SiO2'] = ((-2.137e-5*P-9.83e-4)*F**2 + (5.975e-3*P+8.513e-2)*F
                    +(-4.236e-1*P+4.638e1))
    comp['Al2O3'] = ((-1.908e-4*P-1.366e-4)*F**2+(4.589e-2*P-1.525e-1)*F
                    +(-2.685*P+2.087e1))
    comp['FeO'] = ((2.365e-4*P-8.492e-4)*F**2+(-3.723e-2*P+1.1e-1)*F
                    +(1.366*P+5.488))
    comp['MgO'] = ((-8.068e-5*P+1.747e-3)*F**2+(-1.268e-2*P+9.761e-2)*F
                    +(2.12*P+9.914))
    comp['CaO'] = ((4.305e-5*P-4.513e-4)*F**2+(1.104e-3*P-4.948e-2)*F
                    +(-5.564e-1*P+1.294e1))

    comp['TiO2'] = 12.370*F**-0.917
    comp['Na2O'] = 5.339*F**-0.654
    comp['K2O'] = 6.612*F**-0.923

    limTiO2 = 12.370*3**-0.917
    limNa2O = 5.339*3**-0.654
    limK2O = 6.612*3**-0.923

    comp.TiO2[comp.TiO2>limTiO2] = limTiO2
    comp.Na2O[comp.Na2O>limNa2O] = limNa2O
    comp.K2O[comp.K2O>limK2O] = limK2O

    comp['Cr2O3'] = -7.86e-5*F**2 + 9.705e-3*F + 2.201e-1
    comp['MnO'] = -6.757e-6*F**2 + -2.04e-5*F + 2.014e-1

    T = ((8.597e-3*P-1.963e-2)*F**2 + (-1.374*P+7.383)*F + 9.369e1*P + 1.177e3)

    return comp, T
